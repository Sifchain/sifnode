import { AssetAmount, IAssetAmount } from "../entities/AssetAmount_";
import { IAsset, Asset } from "./Asset_";
import numeral from "numeral";

// Read numbro docs
// https://numbrojs.com/format.html

type StrategyDefault = {
  kind?: false;
  size: number;
};

type ShorthandStrategy = {
  kind: "shorthand";
  size: number;
  commas: boolean;
};

type Strategy = StrategyDefault | ShorthandStrategy;

function formatt(data: StrategyDefault): number;
function formatt(data: ShorthandStrategy): number;
function formatt(data: Strategy): number {
  return 1;
}

formatt({ kind: "shorthand", commas: true, size: 10 });

// const aAmount = AssetAmount(USD, JSBI.BigInt("10012"));

// locale
// localStorage - side effects
// wrap in context | inject | (useFormat || format) (deconstruct from ctx generated by a factory function)
// add as more arguments for format
// factory function
/*
delimiters: {
    thousands: ' ',
    decimal: ','
},
abbreviations: {
    thousand: 'k',
    million: 'm',
    billion: 'b',
    trillion: 't'
},
ordinal : function (number) {
    return number === 1 ? 'er' : 'ème';
},
currency: {
    symbol: '€'
}
*/

export default function format(amount: IAssetAmount): string {
  // return amount.toFixed();

  /*
    separate into parts
    all options must work with JSBI

    rightPad

  */

  if (localStorage.get("user_pref_use_locale")) return "100";
}

// maybe 80% of the time when building out the UX there will be named types
// 'short-amount', 'short-meaning-ful-balance' etc
// format(aAmount, 'short-amount');
// vs
// format(aAmount, { decimals: 2, commas: true })
// this might be over thinking, maybe it isn't that bad having explicit values
// over and over again in calls to format
// and/or keep format explicit and rely on components to handle abstractions

/*
perhaps another export formatF etc

format(aAmount, 'large-price') {
  return format(aAmount, { decimals: 8, commas: true })
}

*/
