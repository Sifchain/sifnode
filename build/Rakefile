require 'rake'
require 'rbconfig'
require 'yaml'
require 'digest'

desc "management processes for the kube cluster and terraform commands"
namespace :cluster do
  desc "Scaffold new cluster environment configuration from template"
  task :scaffold, [:chainnet, :provider] do |t, args|
    check_args(args)

    # create path location
    system('mkdir -p ../.live')
    system("mkdir #{path(args)}") or exit

    # create config from template
    system("go run github.com/belitre/gotpl ./terraform/template/aws/cluster.tf.tpl \
      --set chainnet=#{args[:chainnet]} \
      > #{path(args)}/main.tf
    ")

    system("go run github.com/belitre/gotpl ./terraform/template/aws/.envrc.tpl \
      --set chainnet=#{args[:chainnet]} \
      > #{path(args)}/.envrc
    ")

    # init terraform
    system("cd #{path(args)} && terraform init")

    puts "Cluster configuration scaffolding complete: #{path(args)}"
    puts "Now run `rake cluster:create[#{args[:chainnet]},#{args[:provider]}]` to deploy your cluster"
  end

  desc "Create cluster"
  task :create, [:chainnet, :provider] do |t, args|
    check_args(args)
    puts "Deploy cluster config: #{path(args)}"
    system("cd #{path(args)} && terraform apply") or exit 1
    puts "Cluster #{path(args)} created successfully"
    puts "Now run `rake sifnode:install[#{args[:chainnet]},#{args[:provider]}]` to deploy sifnode to your cluster"
  end

  task :destroy, [:chainnet, :provider] do |t, args|
    check_args(args)
    puts "Destroy running cluster: #{path(args)}"
    system("cd #{path(args)} && terraform destroy") or exit 1
    puts "Cluster #{path(args)} destroyed successfully"
  end
end

desc "Manage sifnode install, upgrade, etc processes"
namespace :sifnode do
  desc "Install sifnode on cluster"
  task :install, [:chainnet, :provider, :namespace, :image, :image_tag] do |t, args|
    check_args(args)

    cmd = %Q{helm upgrade #{ns(args)} ../build/helm/sifnode \
        --set sifnode.env.chainnet=#{args[:chainnet]} --install -n #{ns(args)} --create-namespace \
        --set image.tag=#{image_tag(args)} \
        --set image.repository=#{image_repository(args)}
    }

    system({"KUBECONFIG" => kubeconfig(args) }, cmd)
  end

  task :uninstall, [:chainnet, :provider, :namespace] do |t, args|
    check_args(args)
    cmd = "helm delete #{ns(args)} -n #{ns(args)}"
    system({"KUBECONFIG" => kubeconfig(args) }, cmd)
  end
end

desc "Install require dependencies"
namespace :dependencies do
  desc "Install terraform and Helm for OSX"
  task :install do
    case detect_os
    when :macosx
      puts "Installing Terraform"
      system("brew install terraform")

      puts "Installing aws-iam-authenticator"
      system("brew install aws-iam-authenticator")

      puts "Installing kubectl"
      system("brew install kubernetes-cli")

      puts "Installing Helm 3"
      system("brew install helm")
    when :linux
      # TODO complete....
      puts "Installing aws-iam-authenticator"
      system("curl -o aws-iam-authenticator https://amazon-eks.s3.us-west-2.amazonaws.com/1.18.8/2020-09-18/bin/linux/amd64/aws-iam-authenticator")

      puts "Installig helm"
      system("curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash")
    else
      puts "Sorry not currently supported!"
    end
  end
end

desc "network operations"
namespace :network do
  desc "build and launch a new network"
  task :compose, [:chainnet, :validator_count, :build_dir, :seed_ip_address, :seed_network_address] do |t, args|
    network_config = "#{args[:build_dir]}/#{Digest::SHA256.hexdigest args[:chainnet]}.yml"

    network_create({chainnet: args[:chainnet], validator_count: args[:validator_count],
                    build_dir: args[:build_dir], seed_ip_address: args[:seed_ip_address],
                    network_config: network_config})

    network_boot({chainnet: args[:chainnet], network_config: network_config,
                  seed_network_address: args[:seed_network_address]})
  end

  desc "build the config and generate the keys for a new network"
  task :build, [:chainnet, :validator_count, :build_dir, :seed_ip_address] do |t, args|
    network_create({chainnet: args[:chainnet], validator_count: args[:validator_count],
                    build_dir: args[:build_dir], seed_ip_address: args[:seed_ip_address]})
  end

  desc "boot the new network"
  task :launch, [:chainnet, :network_config, :seed_network_address] do |t, args|
    if !File.file?(network_config)
      puts "the file #{network_config} does not exist!"
      exit(1)
    end

    network_boot({chainnet: args[:chainnet], network_config: network_config,
                  seed_network_address: args[:seed_network_address]})
  end
end

desc "node operations"
namespace :node do
  desc "create a new node and configure it to connect to an existing network"
  task :create, [:chainnet, :peer_address, :genesis_url] do |t, args|
    system("sifgen node create #{args[:chainnet]} #{args[:peer_address]} #{args[:genesis_url]}")
  end
end

# path returns the path of the terraform config that is generated as part of the scaffold task
def path(args)
  "../.live/sifchain-#{args[:provider]}-#{args[:chainnet]}"
end

# check_args checks to make sure the required args are passed in
def check_args(args)
  if args[:chainnet] == nil
    puts "Please provider a chainnet argument E.g testnet, mainnet, etc"
    exit
  end

  case args[:provider]
  when "aws"
  when "az"
    puts "Build me!"
    exit
  when "gcp"
    puts "Build me!"
    exit
  when "do"
    puts "Build me!"
    exit
  else
    puts "Please provide a cloud host provider. E.g aws"
    exit
  end
end

# kubeconfig returns the path to the kubeconfig file based on the args
def kubeconfig(args)
  "#{path(args)}/kubeconfig_sifchain-#{args[:provider]}-#{args[:chainnet]}"
end

# ns = namespace for kubes returns the arg with the namespace if set or the default setting
def ns(args)
  args[:namespace] ? "#{args[:namespace]}" : "sifnode"
end

# image_tag returns the arg for image_tag if set or the default tag setting
def image_tag(args)
    args[:image_tag] ? "#{args[:image_tag]}" : "testnet"
end

# image_repository returns the arg with a image_repository if set or the default setting
def image_repository(args)
  args[:image_repository] ? "#{args[:image_repository]}" : "sifchain/sifnoded"
end

def detect_os
  @os ||= (
  host_os = RbConfig::CONFIG['host_os']
  case host_os
  when /mswin|msys|mingw|cygwin|bccwin|wince|emc/
    :windows
  when /darwin|mac os/
    :macosx
  when /linux/
    :linux
  when /solaris|bsd/
    :unix
  else
    raise Error::WebDriverError, "unknown os: #{host_os.inspect}"
  end
  )
end

# Creates the config for a new network.
def network_create(chainnet:, validator_count:, build_dir:, seed_ip_address:, network_config:)
  system("sifgen network create #{chainnet} #{validator_count} #{build_dir} #{seed_ip_address} #{network_config}")
end

# Boot the new network.
def network_boot(chainnet:, network_config:, seed_network_address:)
  network_image(chainnet)

  network = YAML.load_file(network_config)

  cmd = "CHAINNET=#{chainnet} "
  network.each_with_index do |node, idx|
    cmd += "MONIKER#{idx+1}=#{node['moniker']} IPV4_ADDRESS#{idx+1}=#{node['ipv4_address']} "
  end

  cmd += "IPV4_SUBNET=#{seed_network_address} docker-compose -f ./docker-compose.yml up"
  system(cmd)
end

# Create a docker image for the new network
def network_image(chainnet)
  system("docker build -f ../cmd/sifnoded/Dockerfile -t sifchain/sifnode:#{chainnet} .")
end
