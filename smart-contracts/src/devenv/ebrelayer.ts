import * as ChildProcess from "child_process"
import { EthereumAddressAndKey, ShellCommand } from "./devEnv"
import { EbRelayerAccount, ValidatorValues, waitForSifAccount } from "./sifnoded"
import { DeployedContractAddresses } from "../../scripts/deploy_contracts_dev"
import notifier from "node-notifier"
import { GolangResults } from "./golangBuilder"
import * as fs from "fs"
import * as path from "path"

export interface EbrelayerArguments {
  readonly validatorValues: ValidatorValues
  readonly account: EthereumAddressAndKey
  readonly smartContract: DeployedContractAddresses
  readonly sifnodeAccount: EbRelayerAccount
  // TODO: This is generated by golangBuilder, passed through unnecessary layers
  readonly golangResults: GolangResults
  readonly chainId: number
}

interface EbrelayerResults {
  process: ChildProcess.ChildProcess
}

export class WitnessRunner extends ShellCommand<EbrelayerResults> {
  private output: Promise<EbrelayerResults>
  private outputResolve: any
  constructor(
    readonly args: EbrelayerArguments,
    readonly websocketAddress = "ws://localhost:8545/",
    // TODO: This naming isnt specific enough
    readonly tcpURL = "tcp://0.0.0.0:26657",
    readonly chainNet = "localnet",
    readonly witnessDB = `WitnessDB.db`,
    readonly relayerdbPath = "./witnessdb",
    readonly symbolTranslatorFile = "../test/integration/config/symbol_translator.json",
    readonly logFile = "/tmp/sifnode/witness.log"
  ) {
    super()
    this.output = new Promise<EbrelayerResults>((res, rej) => {
      this.outputResolve = res
    })
  }

  cmd(): [string, string[]] {
    let witnessCmd: [string, string[]] = [
      "ebrelayer",
      [
        "init-witness",
        "--network-descriptor",
        String(this.args.chainId),
        "--tendermint-node",
        this.tcpURL,
        "--web3-provider",
        this.websocketAddress,
        "--bridge-registry-contract-address",
        this.args.smartContract.bridgeRegistry,
        "--validator-moniker",
        this.args.sifnodeAccount.name,
        "--chain-id",
        String(this.chainNet),
        "--node",
        String(this.tcpURL),
        "--keyring-backend",
        "test",
        "--from",
        this.args.sifnodeAccount.account,
        "--symbol-translator-file",
        this.symbolTranslatorFile,
        "--home",
        this.args.sifnodeAccount.homeDir,
        "--keyring-dir",
        this.args.sifnodeAccount.homeDir,
        "--log_format",
        "json",
      ],
    ]
    // TODO: Switch this to debug
    console.log("Running witness command", witnessCmd)
    return witnessCmd
  }

  override async run(): Promise<void> {
    const sifnodedCommand = path.join(this.args.golangResults.goBin, "sifnoded")
    await waitForSifAccount(this.args.validatorValues.address, sifnodedCommand)
    process.env["ETHEREUM_PRIVATE_KEY"] = this.args.account.privateKey.slice(2)
    process.env["ETHEREUM_ADDRESS"] = this.args.account.address.slice(2)
    const spawncmd = "ebrelayer " + this.cmd()[1].join(" ")
    console.log(`ebrelayer cmd: ${spawncmd}`)
    const witnessLogFile = fs.openSync(this.logFile, "w")
    const commandResult = ChildProcess.spawn(spawncmd, {
      shell: true,
      stdio: ["inherit", witnessLogFile, witnessLogFile],
    })
    commandResult.on("exit", (code) => {
      notifier.notify({
        title: "Witness Notice",
        message: `Sifnode Witness has just exited with exit code: ${code}`,
      })
      fs.closeSync(witnessLogFile)
    })
    this.outputResolve({
      process: commandResult,
    })
  }

  override async results(): Promise<EbrelayerResults> {
    return this.output
  }
}

export class RelayerRunner extends ShellCommand<EbrelayerResults> {
  private output: Promise<EbrelayerResults>
  private outputResolve: any
  constructor(
    readonly args: EbrelayerArguments,
    readonly websocketAddress = "ws://localhost:8545/",
    // TODO: This naming isnt specific enough
    readonly tcpURL = "tcp://0.0.0.0:26657",
    readonly chainNet = "localnet",
    readonly ebrelayerDB = `levelDB.db`,
    readonly relayerdbPath = "./relayerdb",
    readonly symbolTranslatorFile = "../test/integration/config/symbol_translator.json",
    readonly logFile = "/tmp/sifnode/relayer.log"
  ) {
    super()
    this.output = new Promise<EbrelayerResults>((res, rej) => {
      this.outputResolve = res
    })
  }

  cmd(): [string, string[]] {
    let relayerCmd: [string, string[]] = [
      "ebrelayer",
      [
        "init-relayer",
        "--network-descriptor",
        String(this.args.chainId),
        "--tendermint-node",
        this.tcpURL,
        "--web3-provider",
        this.websocketAddress,
        "--bridge-registry-contract-address",
        this.args.smartContract.bridgeRegistry,
        "--validator-moniker",
        this.args.sifnodeAccount.name,
        "--chain-id",
        String(this.chainNet),
        "--node",
        String(this.tcpURL),
        "--keyring-backend",
        "test",
        "--from",
        this.args.sifnodeAccount.account,
        "--symbol-translator-file",
        this.symbolTranslatorFile,
        "--home",
        this.args.sifnodeAccount.homeDir,
        "--keyring-dir",
        this.args.sifnodeAccount.homeDir,
      ],
    ]
    console.log("Running relayer command", relayerCmd)
    return relayerCmd
  }

  override async run(): Promise<void> {
    const sifnodedCommand = path.join(this.args.golangResults.goBin, "sifnoded")
    await waitForSifAccount(this.args.validatorValues.address, sifnodedCommand)
    process.env["ETHEREUM_PRIVATE_KEY"] = this.args.account.privateKey.slice(2)
    process.env["ETHEREUM_ADDRESS"] = this.args.account.address.slice(2)
    const spawncmd = "ebrelayer " + this.cmd()[1].join(" ")
    const ebrelayerLogFile = fs.openSync(this.logFile, "w")
    const commandResult = ChildProcess.spawn(spawncmd, {
      shell: true,
      stdio: ["inherit", ebrelayerLogFile, ebrelayerLogFile],
    })
    commandResult.on("exit", (code) => {
      notifier.notify({
        title: "Ebrelayer Notice",
        message: `Ebrelayer has just exited with exit code: ${code}`,
      })
    })
    this.outputResolve({
      process: commandResult,
    })
  }

  override async results(): Promise<EbrelayerResults> {
    return this.output
  }
}
