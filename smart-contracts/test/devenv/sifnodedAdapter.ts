// TODO: Naming
// TODO: This could be generated by protobuf like how cobra is generated

import { EbRelayerAccount } from "../../src/devenv/sifnoded"
import { v4 as uuidv4 } from "uuid"
import * as ChildProcess from "child_process"
import { SignerWithAddress } from "@nomiclabs/hardhat-ethers/signers"
import { BigNumber } from "ethers"
import { exit } from "process"

interface Balance {
  denom: string
  amount: string
}

interface Balances {
  balances: Balance[]
}

/**
 * This class is the interface to interact with sifnoded CLI.
 */
const ROWAN_SYMBOL = "rowan"
const DEFAULT_PREPAY_AMOUNT = 10000000000
export class SifnodedAdapter {
  private readonly homedir: string
  private readonly adminAccount: string
  private readonly gobin: string

  constructor(homedir: string, adminAccount: string, gobin: string | undefined) {
    if (gobin == undefined) {
      console.log("GOBIN ENV Var not found, exiting")
      exit(1)
    }
    this.homedir = homedir
    this.adminAccount = adminAccount
    this.gobin = gobin!
  }

  /**
   * Creates an ephemeral test account
   * @param prepayRowan: If true, will fund the account with DEFAULT_PREPAY_AMOUNT of rowan, for sif gas operations
   * @returns an ebrelayerAccount with uuid as name, and a valid sif address
   * TODO: Should the return type be ebrelayeraccount? it's really a sif account
   */
  createTestSifAccount(prepayRowan: boolean = true): EbRelayerAccount {
    const testSifAccountName = uuidv4()
    const keyAddCmd: string = `${this.gobin}/sifnoded keys add ${testSifAccountName} --home ${this.homedir} --keyring-backend test --output json 2>&1`

    const responseString: string = ChildProcess.execSync(keyAddCmd, {
      encoding: "utf8",
    })
    const responseJson = JSON.parse(responseString)

    if (prepayRowan) {
      this.fundSifAccount(responseJson.address, DEFAULT_PREPAY_AMOUNT, ROWAN_SYMBOL)
      console.log("Funded with rowan")
    }

    return {
      name: responseJson.name,
      account: responseJson.address,
      homeDir: "",
    }
  }

  fundSifAccount(destination: string, amount: number, symbol: string): object {
    // template: sifnoded tx bank send adminAccount testAccountToBeFunded --keyring-backend test --chain-id localnet concat(amount,symbol) --gas-prices=0.5rowan --gas-adjustment=1.5 --home <homeDir> --gas auto -y
    const bankSendCmd: string = `${this.gobin}/sifnoded tx bank send ${this.adminAccount} ${destination} --keyring-backend test --chain-id localnet ${amount}${symbol} --gas-prices=0.5rowan --gas-adjustment=1.5 --home ${this.homedir} --gas 2000000000000000000 --node tcp://0.0.0.0:26657 --keyring-dir ${this.homedir} --output json -y`
    const responseString: string = ChildProcess.execSync(bankSendCmd, {
      encoding: "utf8",
    })
    console.log(responseString)
    return JSON.parse(responseString)
  }

  async executeSifBurn(
    sender: EbRelayerAccount,
    destination: SignerWithAddress,
    amount: BigNumber,
    symbol: string,
    // TODO: What is correct value for corsschainfee?
    crossChainFee: string,
    networkDescriptor: number
  ): Promise<object> {
    let sifnodedCmd: string = `${this.gobin}/sifnoded tx ethbridge burn ${destination.address} ${amount} ${symbol} ${crossChainFee} --network-descriptor ${networkDescriptor} --keyring-backend test --gas-prices=0.5rowan --gas-adjustment=1.5 --chain-id localnet --home ${this.homedir} --from ${sender.name} --output json -y `
    console.log("Executing sif burn:", sifnodedCmd)
    let responseString = ChildProcess.execSync(sifnodedCmd, { encoding: "utf8" })
    return JSON.parse(responseString)
  }

  async getBalance(account: string, denomHash: string): Promise<BigNumber> {
    const bankSendCmd: string = `${this.gobin}/sifnoded query bank balances ${account} --chain-id localnet --home ${this.homedir} --node tcp://0.0.0.0:26657 --output json`

    let result = BigNumber.from(0)
    const responseString: string = ChildProcess.execSync(bankSendCmd, {
      encoding: "utf8",
    })
    const balancesJson = JSON.parse(responseString) as Balances

    balancesJson["balances"].forEach((element) => {
      if (element["denom"] === denomHash) {
        result = BigNumber.from(element["amount"])
      }
    })

    return result
  }
}
