// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sifnode/clp/v1/params.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params - used for initializing default parameter for clp at genesis
type Params struct {
	MinCreatePoolThreshold uint64 `protobuf:"varint,1,opt,name=min_create_pool_threshold,json=minCreatePoolThreshold,proto3" json:"min_create_pool_threshold,omitempty"`
	EnableRemovalQueue     bool   `protobuf:"varint,2,opt,name=enable_removal_queue,json=enableRemovalQueue,proto3" json:"enable_removal_queue,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_61de66e331088d04, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetMinCreatePoolThreshold() uint64 {
	if m != nil {
		return m.MinCreatePoolThreshold
	}
	return 0
}

func (m *Params) GetEnableRemovalQueue() bool {
	if m != nil {
		return m.EnableRemovalQueue
	}
	return false
}

type RewardParams struct {
	LiquidityRemovalLockPeriod   uint64          `protobuf:"varint,1,opt,name=liquidity_removal_lock_period,json=liquidityRemovalLockPeriod,proto3" json:"liquidity_removal_lock_period,omitempty"`
	LiquidityRemovalCancelPeriod uint64          `protobuf:"varint,2,opt,name=liquidity_removal_cancel_period,json=liquidityRemovalCancelPeriod,proto3" json:"liquidity_removal_cancel_period,omitempty"`
	RewardPeriods                []*RewardPeriod `protobuf:"bytes,4,rep,name=reward_periods,json=rewardPeriods,proto3" json:"reward_periods,omitempty"`
	RewardPeriodStartTime        string          `protobuf:"bytes,5,opt,name=reward_period_start_time,json=rewardPeriodStartTime,proto3" json:"reward_period_start_time,omitempty"`
}

func (m *RewardParams) Reset()         { *m = RewardParams{} }
func (m *RewardParams) String() string { return proto.CompactTextString(m) }
func (*RewardParams) ProtoMessage()    {}
func (*RewardParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_61de66e331088d04, []int{1}
}
func (m *RewardParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardParams.Merge(m, src)
}
func (m *RewardParams) XXX_Size() int {
	return m.Size()
}
func (m *RewardParams) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardParams.DiscardUnknown(m)
}

var xxx_messageInfo_RewardParams proto.InternalMessageInfo

func (m *RewardParams) GetLiquidityRemovalLockPeriod() uint64 {
	if m != nil {
		return m.LiquidityRemovalLockPeriod
	}
	return 0
}

func (m *RewardParams) GetLiquidityRemovalCancelPeriod() uint64 {
	if m != nil {
		return m.LiquidityRemovalCancelPeriod
	}
	return 0
}

func (m *RewardParams) GetRewardPeriods() []*RewardPeriod {
	if m != nil {
		return m.RewardPeriods
	}
	return nil
}

func (m *RewardParams) GetRewardPeriodStartTime() string {
	if m != nil {
		return m.RewardPeriodStartTime
	}
	return ""
}

// These params are non-governable and are calculated on chain
type PmtpRateParams struct {
	PmtpPeriodBlockRate    github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=pmtp_period_block_rate,json=pmtpPeriodBlockRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"pmtp_period_block_rate"`
	PmtpCurrentRunningRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=pmtp_current_running_rate,json=pmtpCurrentRunningRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"pmtp_current_running_rate"`
	PmtpInterPolicyRate    github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=pmtp_inter_policy_rate,json=pmtpInterPolicyRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"pmtp_inter_policy_rate"`
}

func (m *PmtpRateParams) Reset()         { *m = PmtpRateParams{} }
func (m *PmtpRateParams) String() string { return proto.CompactTextString(m) }
func (*PmtpRateParams) ProtoMessage()    {}
func (*PmtpRateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_61de66e331088d04, []int{2}
}
func (m *PmtpRateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PmtpRateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PmtpRateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PmtpRateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PmtpRateParams.Merge(m, src)
}
func (m *PmtpRateParams) XXX_Size() int {
	return m.Size()
}
func (m *PmtpRateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_PmtpRateParams.DiscardUnknown(m)
}

var xxx_messageInfo_PmtpRateParams proto.InternalMessageInfo

type PmtpParams struct {
	PmtpPeriodGovernanceRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=pmtp_period_governance_rate,json=pmtpPeriodGovernanceRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"pmtp_period_governance_rate"`
	PmtpPeriodEpochLength    int64                                  `protobuf:"varint,2,opt,name=pmtp_period_epoch_length,json=pmtpPeriodEpochLength,proto3" json:"pmtp_period_epoch_length,omitempty"`
	PmtpPeriodStartBlock     int64                                  `protobuf:"varint,3,opt,name=pmtp_period_start_block,json=pmtpPeriodStartBlock,proto3" json:"pmtp_period_start_block,omitempty"`
	PmtpPeriodEndBlock       int64                                  `protobuf:"varint,4,opt,name=pmtp_period_end_block,json=pmtpPeriodEndBlock,proto3" json:"pmtp_period_end_block,omitempty"`
}

func (m *PmtpParams) Reset()         { *m = PmtpParams{} }
func (m *PmtpParams) String() string { return proto.CompactTextString(m) }
func (*PmtpParams) ProtoMessage()    {}
func (*PmtpParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_61de66e331088d04, []int{3}
}
func (m *PmtpParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PmtpParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PmtpParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PmtpParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PmtpParams.Merge(m, src)
}
func (m *PmtpParams) XXX_Size() int {
	return m.Size()
}
func (m *PmtpParams) XXX_DiscardUnknown() {
	xxx_messageInfo_PmtpParams.DiscardUnknown(m)
}

var xxx_messageInfo_PmtpParams proto.InternalMessageInfo

func (m *PmtpParams) GetPmtpPeriodEpochLength() int64 {
	if m != nil {
		return m.PmtpPeriodEpochLength
	}
	return 0
}

func (m *PmtpParams) GetPmtpPeriodStartBlock() int64 {
	if m != nil {
		return m.PmtpPeriodStartBlock
	}
	return 0
}

func (m *PmtpParams) GetPmtpPeriodEndBlock() int64 {
	if m != nil {
		return m.PmtpPeriodEndBlock
	}
	return 0
}

type RewardPeriod struct {
	RewardPeriodId                string                                   `protobuf:"bytes,1,opt,name=reward_period_id,json=rewardPeriodId,proto3" json:"reward_period_id,omitempty"`
	RewardPeriodStartBlock        uint64                                   `protobuf:"varint,2,opt,name=reward_period_start_block,json=rewardPeriodStartBlock,proto3" json:"reward_period_start_block,omitempty"`
	RewardPeriodEndBlock          uint64                                   `protobuf:"varint,3,opt,name=reward_period_end_block,json=rewardPeriodEndBlock,proto3" json:"reward_period_end_block,omitempty"`
	RewardPeriodAllocation        *github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,4,opt,name=reward_period_allocation,json=rewardPeriodAllocation,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"reward_period_allocation,omitempty"`
	RewardPeriodPoolMultipliers   []*PoolMultiplier                        `protobuf:"bytes,5,rep,name=reward_period_pool_multipliers,json=rewardPeriodPoolMultipliers,proto3" json:"reward_period_pool_multipliers,omitempty"`
	RewardPeriodDefaultMultiplier *github_com_cosmos_cosmos_sdk_types.Dec  `protobuf:"bytes,6,opt,name=reward_period_default_multiplier,json=rewardPeriodDefaultMultiplier,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"reward_period_default_multiplier,omitempty"`
	RewardPeriodDistribute        bool                                     `protobuf:"varint,7,opt,name=reward_period_distribute,json=rewardPeriodDistribute,proto3" json:"reward_period_distribute,omitempty"`
	RewardPeriodMod               uint64                                   `protobuf:"varint,8,opt,name=reward_period_mod,json=rewardPeriodMod,proto3" json:"reward_period_mod,omitempty"`
}

func (m *RewardPeriod) Reset()         { *m = RewardPeriod{} }
func (m *RewardPeriod) String() string { return proto.CompactTextString(m) }
func (*RewardPeriod) ProtoMessage()    {}
func (*RewardPeriod) Descriptor() ([]byte, []int) {
	return fileDescriptor_61de66e331088d04, []int{4}
}
func (m *RewardPeriod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardPeriod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardPeriod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardPeriod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardPeriod.Merge(m, src)
}
func (m *RewardPeriod) XXX_Size() int {
	return m.Size()
}
func (m *RewardPeriod) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardPeriod.DiscardUnknown(m)
}

var xxx_messageInfo_RewardPeriod proto.InternalMessageInfo

func (m *RewardPeriod) GetRewardPeriodId() string {
	if m != nil {
		return m.RewardPeriodId
	}
	return ""
}

func (m *RewardPeriod) GetRewardPeriodStartBlock() uint64 {
	if m != nil {
		return m.RewardPeriodStartBlock
	}
	return 0
}

func (m *RewardPeriod) GetRewardPeriodEndBlock() uint64 {
	if m != nil {
		return m.RewardPeriodEndBlock
	}
	return 0
}

func (m *RewardPeriod) GetRewardPeriodPoolMultipliers() []*PoolMultiplier {
	if m != nil {
		return m.RewardPeriodPoolMultipliers
	}
	return nil
}

func (m *RewardPeriod) GetRewardPeriodDistribute() bool {
	if m != nil {
		return m.RewardPeriodDistribute
	}
	return false
}

func (m *RewardPeriod) GetRewardPeriodMod() uint64 {
	if m != nil {
		return m.RewardPeriodMod
	}
	return 0
}

type PoolMultiplier struct {
	PoolMultiplierAsset string                                  `protobuf:"bytes,1,opt,name=pool_multiplier_asset,json=poolMultiplierAsset,proto3" json:"pool_multiplier_asset,omitempty"`
	Multiplier          *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=multiplier,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"multiplier,omitempty"`
}

func (m *PoolMultiplier) Reset()         { *m = PoolMultiplier{} }
func (m *PoolMultiplier) String() string { return proto.CompactTextString(m) }
func (*PoolMultiplier) ProtoMessage()    {}
func (*PoolMultiplier) Descriptor() ([]byte, []int) {
	return fileDescriptor_61de66e331088d04, []int{5}
}
func (m *PoolMultiplier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolMultiplier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolMultiplier.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolMultiplier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolMultiplier.Merge(m, src)
}
func (m *PoolMultiplier) XXX_Size() int {
	return m.Size()
}
func (m *PoolMultiplier) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolMultiplier.DiscardUnknown(m)
}

var xxx_messageInfo_PoolMultiplier proto.InternalMessageInfo

func (m *PoolMultiplier) GetPoolMultiplierAsset() string {
	if m != nil {
		return m.PoolMultiplierAsset
	}
	return ""
}

type LiquidityProtectionParams struct {
	MaxRowanLiquidityThreshold      github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,1,opt,name=max_rowan_liquidity_threshold,json=maxRowanLiquidityThreshold,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"max_rowan_liquidity_threshold"`
	MaxRowanLiquidityThresholdAsset string                                  `protobuf:"bytes,2,opt,name=max_rowan_liquidity_threshold_asset,json=maxRowanLiquidityThresholdAsset,proto3" json:"max_rowan_liquidity_threshold_asset,omitempty"`
	EpochLength                     uint64                                  `protobuf:"varint,3,opt,name=epoch_length,json=epochLength,proto3" json:"epoch_length,omitempty"`
	IsActive                        bool                                    `protobuf:"varint,4,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
}

func (m *LiquidityProtectionParams) Reset()         { *m = LiquidityProtectionParams{} }
func (m *LiquidityProtectionParams) String() string { return proto.CompactTextString(m) }
func (*LiquidityProtectionParams) ProtoMessage()    {}
func (*LiquidityProtectionParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_61de66e331088d04, []int{6}
}
func (m *LiquidityProtectionParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityProtectionParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityProtectionParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityProtectionParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityProtectionParams.Merge(m, src)
}
func (m *LiquidityProtectionParams) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityProtectionParams) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityProtectionParams.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityProtectionParams proto.InternalMessageInfo

func (m *LiquidityProtectionParams) GetMaxRowanLiquidityThresholdAsset() string {
	if m != nil {
		return m.MaxRowanLiquidityThresholdAsset
	}
	return ""
}

func (m *LiquidityProtectionParams) GetEpochLength() uint64 {
	if m != nil {
		return m.EpochLength
	}
	return 0
}

func (m *LiquidityProtectionParams) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

type LiquidityProtectionRateParams struct {
	CurrentRowanLiquidityThreshold github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,1,opt,name=current_rowan_liquidity_threshold,json=currentRowanLiquidityThreshold,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"current_rowan_liquidity_threshold"`
}

func (m *LiquidityProtectionRateParams) Reset()         { *m = LiquidityProtectionRateParams{} }
func (m *LiquidityProtectionRateParams) String() string { return proto.CompactTextString(m) }
func (*LiquidityProtectionRateParams) ProtoMessage()    {}
func (*LiquidityProtectionRateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_61de66e331088d04, []int{7}
}
func (m *LiquidityProtectionRateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityProtectionRateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityProtectionRateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityProtectionRateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityProtectionRateParams.Merge(m, src)
}
func (m *LiquidityProtectionRateParams) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityProtectionRateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityProtectionRateParams.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityProtectionRateParams proto.InternalMessageInfo

type ProviderDistributionPeriod struct {
	DistributionPeriodBlockRate  github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=distribution_period_block_rate,json=distributionPeriodBlockRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"distribution_period_block_rate"`
	DistributionPeriodStartBlock uint64                                 `protobuf:"varint,2,opt,name=distribution_period_start_block,json=distributionPeriodStartBlock,proto3" json:"distribution_period_start_block,omitempty"`
	DistributionPeriodEndBlock   uint64                                 `protobuf:"varint,3,opt,name=distribution_period_end_block,json=distributionPeriodEndBlock,proto3" json:"distribution_period_end_block,omitempty"`
	DistributionPeriodMod        uint64                                 `protobuf:"varint,4,opt,name=distribution_period_mod,json=distributionPeriodMod,proto3" json:"distribution_period_mod,omitempty"`
}

func (m *ProviderDistributionPeriod) Reset()         { *m = ProviderDistributionPeriod{} }
func (m *ProviderDistributionPeriod) String() string { return proto.CompactTextString(m) }
func (*ProviderDistributionPeriod) ProtoMessage()    {}
func (*ProviderDistributionPeriod) Descriptor() ([]byte, []int) {
	return fileDescriptor_61de66e331088d04, []int{8}
}
func (m *ProviderDistributionPeriod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderDistributionPeriod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderDistributionPeriod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderDistributionPeriod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderDistributionPeriod.Merge(m, src)
}
func (m *ProviderDistributionPeriod) XXX_Size() int {
	return m.Size()
}
func (m *ProviderDistributionPeriod) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderDistributionPeriod.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderDistributionPeriod proto.InternalMessageInfo

func (m *ProviderDistributionPeriod) GetDistributionPeriodStartBlock() uint64 {
	if m != nil {
		return m.DistributionPeriodStartBlock
	}
	return 0
}

func (m *ProviderDistributionPeriod) GetDistributionPeriodEndBlock() uint64 {
	if m != nil {
		return m.DistributionPeriodEndBlock
	}
	return 0
}

func (m *ProviderDistributionPeriod) GetDistributionPeriodMod() uint64 {
	if m != nil {
		return m.DistributionPeriodMod
	}
	return 0
}

type ProviderDistributionParams struct {
	DistributionPeriods []*ProviderDistributionPeriod `protobuf:"bytes,1,rep,name=distribution_periods,json=distributionPeriods,proto3" json:"distribution_periods,omitempty"`
}

func (m *ProviderDistributionParams) Reset()         { *m = ProviderDistributionParams{} }
func (m *ProviderDistributionParams) String() string { return proto.CompactTextString(m) }
func (*ProviderDistributionParams) ProtoMessage()    {}
func (*ProviderDistributionParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_61de66e331088d04, []int{9}
}
func (m *ProviderDistributionParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderDistributionParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderDistributionParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderDistributionParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderDistributionParams.Merge(m, src)
}
func (m *ProviderDistributionParams) XXX_Size() int {
	return m.Size()
}
func (m *ProviderDistributionParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderDistributionParams.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderDistributionParams proto.InternalMessageInfo

func (m *ProviderDistributionParams) GetDistributionPeriods() []*ProviderDistributionPeriod {
	if m != nil {
		return m.DistributionPeriods
	}
	return nil
}

func init() {
	proto.RegisterType((*Params)(nil), "sifnode.clp.v1.Params")
	proto.RegisterType((*RewardParams)(nil), "sifnode.clp.v1.RewardParams")
	proto.RegisterType((*PmtpRateParams)(nil), "sifnode.clp.v1.PmtpRateParams")
	proto.RegisterType((*PmtpParams)(nil), "sifnode.clp.v1.PmtpParams")
	proto.RegisterType((*RewardPeriod)(nil), "sifnode.clp.v1.RewardPeriod")
	proto.RegisterType((*PoolMultiplier)(nil), "sifnode.clp.v1.PoolMultiplier")
	proto.RegisterType((*LiquidityProtectionParams)(nil), "sifnode.clp.v1.LiquidityProtectionParams")
	proto.RegisterType((*LiquidityProtectionRateParams)(nil), "sifnode.clp.v1.LiquidityProtectionRateParams")
	proto.RegisterType((*ProviderDistributionPeriod)(nil), "sifnode.clp.v1.ProviderDistributionPeriod")
	proto.RegisterType((*ProviderDistributionParams)(nil), "sifnode.clp.v1.ProviderDistributionParams")
}

func init() { proto.RegisterFile("sifnode/clp/v1/params.proto", fileDescriptor_61de66e331088d04) }

var fileDescriptor_61de66e331088d04 = []byte{
	// 1036 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x5f, 0x6f, 0x1b, 0xc5,
	0x17, 0xcd, 0xda, 0x6e, 0x7e, 0xf1, 0x6d, 0x7f, 0x06, 0x36, 0x76, 0xb2, 0xb1, 0xe3, 0xb5, 0x6b,
	0x24, 0xb0, 0x82, 0xb0, 0x49, 0x51, 0x29, 0x3c, 0x3a, 0x7f, 0x84, 0x8a, 0x52, 0xc9, 0x6c, 0xcb,
	0x0b, 0x12, 0x5a, 0xad, 0x77, 0x27, 0xf6, 0x28, 0xbb, 0x3b, 0xdb, 0x99, 0x59, 0x37, 0x81, 0x2f,
	0xd1, 0x27, 0x5e, 0x10, 0x7c, 0x1b, 0xa4, 0x3e, 0x16, 0xf1, 0x82, 0xfa, 0x10, 0xa1, 0xe4, 0x8b,
	0xa0, 0x99, 0x59, 0xaf, 0x77, 0x6d, 0x07, 0xb5, 0x11, 0x4f, 0xc9, 0xfa, 0xce, 0x3d, 0xe7, 0xce,
	0xb9, 0x77, 0xce, 0x0c, 0x34, 0x18, 0x3e, 0x0d, 0x89, 0x87, 0xfa, 0xae, 0x1f, 0xf5, 0xa7, 0xfb,
	0xfd, 0xc8, 0xa1, 0x4e, 0xc0, 0x7a, 0x11, 0x25, 0x9c, 0xe8, 0x95, 0x24, 0xd8, 0x73, 0xfd, 0xa8,
	0x37, 0xdd, 0xaf, 0x57, 0xc7, 0x64, 0x4c, 0x64, 0xa8, 0x2f, 0xfe, 0x53, 0xab, 0x3a, 0x31, 0xac,
	0x0f, 0x65, 0x96, 0xfe, 0x15, 0xec, 0x04, 0x38, 0xb4, 0x5d, 0x8a, 0x1c, 0x8e, 0xec, 0x88, 0x10,
	0xdf, 0xe6, 0x13, 0x8a, 0xd8, 0x84, 0xf8, 0x9e, 0xa1, 0xb5, 0xb5, 0x6e, 0xc9, 0xda, 0x0a, 0x70,
	0x78, 0x28, 0xe3, 0x43, 0x42, 0xfc, 0x67, 0xb3, 0xa8, 0xfe, 0x19, 0x54, 0x51, 0xe8, 0x8c, 0x7c,
	0x64, 0x53, 0x14, 0x90, 0xa9, 0xe3, 0xdb, 0xcf, 0x63, 0x14, 0x23, 0xa3, 0xd0, 0xd6, 0xba, 0x1b,
	0x96, 0xae, 0x62, 0x96, 0x0a, 0x7d, 0x2b, 0x22, 0x9d, 0x9f, 0x0b, 0x70, 0xcf, 0x42, 0x2f, 0x1c,
	0xea, 0x25, 0xec, 0x03, 0x68, 0xfa, 0xf8, 0x79, 0x8c, 0x3d, 0xcc, 0x2f, 0x52, 0x14, 0x9f, 0xb8,
	0x67, 0x76, 0x84, 0x28, 0x26, 0xb3, 0x0a, 0xea, 0xe9, 0xa2, 0x04, 0xee, 0x84, 0xb8, 0x67, 0x43,
	0xb9, 0x42, 0x3f, 0x86, 0xd6, 0x32, 0x84, 0xeb, 0x84, 0x2e, 0xf2, 0x67, 0x20, 0x05, 0x09, 0xb2,
	0xbb, 0x08, 0x72, 0x28, 0x17, 0x25, 0x30, 0x87, 0x50, 0xa1, 0xb2, 0xb2, 0x24, 0x89, 0x19, 0xa5,
	0x76, 0xb1, 0x7b, 0xf7, 0xc1, 0x6e, 0x2f, 0x2f, 0x68, 0x2f, 0xa9, 0x5f, 0x2e, 0xb2, 0xfe, 0x4f,
	0x33, 0x5f, 0x4c, 0x7f, 0x04, 0x46, 0x0e, 0xc4, 0x66, 0xdc, 0xa1, 0xdc, 0xe6, 0x38, 0x40, 0xc6,
	0x9d, 0xb6, 0xd6, 0x2d, 0x5b, 0xb5, 0x6c, 0xc2, 0x53, 0x11, 0x7d, 0x86, 0x03, 0xd4, 0xf9, 0xbd,
	0x00, 0x95, 0x61, 0xc0, 0x23, 0x4b, 0x88, 0xac, 0xa4, 0x71, 0x61, 0x2b, 0x0a, 0x78, 0x34, 0x43,
	0x1a, 0x49, 0x55, 0xa8, 0xc3, 0x95, 0xbe, 0xe5, 0x83, 0xde, 0xab, 0xcb, 0xd6, 0xda, 0x9b, 0xcb,
	0xd6, 0x47, 0x63, 0xcc, 0x27, 0xf1, 0xa8, 0xe7, 0x92, 0xa0, 0xef, 0x12, 0x16, 0x10, 0x96, 0xfc,
	0xf9, 0x94, 0x79, 0x67, 0x7d, 0x7e, 0x11, 0x21, 0xd6, 0x3b, 0x42, 0xae, 0xb5, 0x29, 0xd0, 0x14,
	0xef, 0x81, 0xc0, 0x12, 0x54, 0x3a, 0x86, 0x1d, 0x49, 0xe2, 0xc6, 0x94, 0xa2, 0x90, 0xdb, 0x34,
	0x0e, 0x43, 0x1c, 0x8e, 0x15, 0x4f, 0xf1, 0x56, 0x3c, 0xb2, 0xea, 0x43, 0x85, 0x67, 0x29, 0x38,
	0x49, 0x35, 0xdb, 0x0f, 0x0e, 0x39, 0xa2, 0x76, 0x44, 0x7c, 0xec, 0x5e, 0x28, 0x9e, 0xd2, 0xed,
	0xf7, 0xf3, 0x58, 0x80, 0x0d, 0x25, 0x96, 0x20, 0xe9, 0xfc, 0x56, 0x00, 0x10, 0x3a, 0x26, 0x1a,
	0x06, 0xd0, 0xc8, 0x6a, 0x38, 0x26, 0x53, 0x44, 0x43, 0xd1, 0x75, 0x45, 0xac, 0xdd, 0x8a, 0xd8,
	0x98, 0x0b, 0xf9, 0x75, 0x0a, 0x28, 0xb7, 0xf8, 0x08, 0x8c, 0x2c, 0x1d, 0x8a, 0x88, 0x3b, 0xb1,
	0x7d, 0x14, 0x8e, 0xf9, 0x44, 0x36, 0xad, 0x68, 0xd5, 0xe6, 0xb9, 0xc7, 0x22, 0x7a, 0x22, 0x83,
	0xfa, 0x43, 0xd8, 0xce, 0x26, 0xaa, 0xa9, 0x91, 0x1d, 0x97, 0x4d, 0x28, 0x5a, 0xd5, 0x79, 0x9e,
	0x1c, 0x1a, 0xd9, 0x41, 0x7d, 0x1f, 0x6a, 0x39, 0xbe, 0x30, 0x19, 0x13, 0xa9, 0x68, 0xd1, 0xd2,
	0x33, 0x64, 0xa1, 0x6a, 0x7a, 0xe7, 0x8f, 0x52, 0x7a, 0x02, 0xd5, 0xdc, 0x77, 0xe1, 0xfd, 0xfc,
	0xc8, 0x62, 0x75, 0xe8, 0xca, 0x56, 0x25, 0x3b, 0xaa, 0x8f, 0x3d, 0xe1, 0x14, 0xab, 0x86, 0x5b,
	0x31, 0xaa, 0x23, 0xb6, 0xb5, 0x34, 0xdd, 0xaa, 0xd0, 0x87, 0xb0, 0x9d, 0x4f, 0x9d, 0x97, 0x5a,
	0x94, 0x89, 0xd5, 0x6c, 0xe2, 0xac, 0x58, 0x1d, 0x2d, 0x1e, 0x27, 0xc7, 0xf7, 0x89, 0xeb, 0x70,
	0x4c, 0xc2, 0x64, 0x68, 0x3e, 0x79, 0x73, 0xd9, 0xfa, 0xf8, 0x2d, 0xfa, 0xf6, 0x1d, 0x0e, 0x79,
	0xbe, 0xba, 0x41, 0x0a, 0xa5, 0xbb, 0x60, 0xe6, 0x69, 0xa4, 0x0b, 0x06, 0xb1, 0xcf, 0x71, 0xe4,
	0x63, 0x44, 0x99, 0x71, 0x47, 0x5a, 0x81, 0xb9, 0x68, 0x05, 0xc2, 0x0e, 0x9f, 0xa4, 0xcb, 0xac,
	0x46, 0x16, 0x3f, 0x1f, 0x63, 0x3a, 0x83, 0x76, 0x9e, 0xc4, 0x43, 0xa7, 0x4e, 0xec, 0xf3, 0x0c,
	0x8f, 0xb1, 0x2e, 0xf7, 0xb4, 0xf7, 0x0e, 0xb3, 0xd8, 0xcc, 0x52, 0x1e, 0x29, 0xc4, 0x39, 0xab,
	0xfe, 0xe5, 0xa2, 0x80, 0x1e, 0x66, 0x9c, 0xe2, 0x51, 0xcc, 0x91, 0xf1, 0x3f, 0xe9, 0xd2, 0x39,
	0x4d, 0x8e, 0xd2, 0xa8, 0xbe, 0x07, 0x1f, 0xe4, 0x33, 0x03, 0xe2, 0x19, 0x1b, 0xb2, 0x57, 0xef,
	0x65, 0x53, 0x9e, 0x10, 0xaf, 0xf3, 0x52, 0x83, 0x4a, 0x7e, 0xbb, 0xfa, 0x03, 0xa8, 0x2d, 0x88,
	0x68, 0x3b, 0x8c, 0x21, 0x9e, 0x8c, 0xd6, 0x66, 0x94, 0x5b, 0x3e, 0x10, 0x21, 0xfd, 0x1b, 0x80,
	0x8c, 0x16, 0x85, 0x77, 0xd6, 0x22, 0x93, 0xdd, 0xf9, 0xb5, 0x00, 0x3b, 0x27, 0x33, 0xbb, 0x1f,
	0x52, 0xc2, 0x91, 0x2b, 0x5a, 0x9d, 0xd8, 0x02, 0x85, 0x66, 0xe0, 0x9c, 0xdb, 0x94, 0xbc, 0x70,
	0x42, 0x7b, 0x7e, 0x79, 0xe4, 0xef, 0xbd, 0xf2, 0x41, 0x3f, 0x31, 0x86, 0xb7, 0x1e, 0xb0, 0x7a,
	0xe0, 0x9c, 0x5b, 0x02, 0x34, 0xa5, 0x9e, 0x5f, 0x96, 0x27, 0xf0, 0xe1, 0xbf, 0x72, 0x26, 0xfa,
	0xc8, 0x6d, 0x5b, 0xad, 0x9b, 0x81, 0x94, 0x56, 0xf7, 0xe1, 0x5e, 0xce, 0x5d, 0xd4, 0x29, 0xba,
	0x8b, 0x32, 0x9e, 0xd2, 0x80, 0x32, 0x66, 0xb6, 0xe3, 0x72, 0x3c, 0x55, 0x16, 0xbb, 0x61, 0x6d,
	0x60, 0x36, 0x90, 0xdf, 0x9d, 0x5f, 0x34, 0x68, 0xae, 0xd0, 0x27, 0x73, 0xfd, 0xfc, 0x08, 0xf7,
	0xd3, 0x4b, 0xe1, 0xbf, 0xd6, 0xc9, 0x4c, 0x90, 0x6f, 0xd8, 0x62, 0xe7, 0xcf, 0x02, 0xd4, 0x87,
	0x94, 0x4c, 0xb1, 0x87, 0x68, 0x3a, 0x93, 0xa2, 0x7d, 0xca, 0xb2, 0x18, 0x98, 0x5e, 0xe6, 0xd7,
	0x15, 0x37, 0xe4, 0xed, 0x8c, 0xbd, 0xe1, 0x2d, 0x71, 0xcd, 0x6f, 0xca, 0x63, 0x68, 0xad, 0x22,
	0x5d, 0xf6, 0xc0, 0xdd, 0x65, 0x94, 0x8c, 0x13, 0x0e, 0xa0, 0xb9, 0x0a, 0x66, 0xd1, 0x0f, 0xeb,
	0xcb, 0x20, 0xa9, 0x2b, 0x7e, 0x01, 0xdb, 0xab, 0x20, 0xc4, 0x01, 0x2d, 0xc9, 0xe4, 0xda, 0x72,
	0xb2, 0x38, 0xa6, 0x3f, 0xdd, 0x20, 0xaa, 0xea, 0xf7, 0x0f, 0x50, 0x5d, 0x81, 0xca, 0x0c, 0x4d,
	0x5a, 0xdf, 0xde, 0x92, 0xf5, 0xdd, 0xd8, 0x1e, 0x6b, 0x73, 0x99, 0x9e, 0x1d, 0x0c, 0x5e, 0x5d,
	0x99, 0xda, 0xeb, 0x2b, 0x53, 0xfb, 0xfb, 0xca, 0xd4, 0x5e, 0x5e, 0x9b, 0x6b, 0xaf, 0xaf, 0xcd,
	0xb5, 0xbf, 0xae, 0xcd, 0xb5, 0xef, 0xb3, 0x53, 0xf3, 0x14, 0x9f, 0xba, 0x13, 0x07, 0x87, 0xfd,
	0xd9, 0x0b, 0xf7, 0x5c, 0xbe, 0x71, 0x65, 0x8b, 0x46, 0xeb, 0xf2, 0xe9, 0xfa, 0xf9, 0x3f, 0x01,
	0x00, 0x00, 0xff, 0xff, 0x84, 0x7c, 0x96, 0xe4, 0xff, 0x0a, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableRemovalQueue {
		i--
		if m.EnableRemovalQueue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.MinCreatePoolThreshold != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MinCreatePoolThreshold))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewardParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardPeriodStartTime) > 0 {
		i -= len(m.RewardPeriodStartTime)
		copy(dAtA[i:], m.RewardPeriodStartTime)
		i = encodeVarintParams(dAtA, i, uint64(len(m.RewardPeriodStartTime)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RewardPeriods) > 0 {
		for iNdEx := len(m.RewardPeriods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardPeriods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintParams(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.LiquidityRemovalCancelPeriod != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.LiquidityRemovalCancelPeriod))
		i--
		dAtA[i] = 0x10
	}
	if m.LiquidityRemovalLockPeriod != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.LiquidityRemovalLockPeriod))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PmtpRateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PmtpRateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PmtpRateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.PmtpInterPolicyRate.Size()
		i -= size
		if _, err := m.PmtpInterPolicyRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.PmtpCurrentRunningRate.Size()
		i -= size
		if _, err := m.PmtpCurrentRunningRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PmtpPeriodBlockRate.Size()
		i -= size
		if _, err := m.PmtpPeriodBlockRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *PmtpParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PmtpParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PmtpParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PmtpPeriodEndBlock != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.PmtpPeriodEndBlock))
		i--
		dAtA[i] = 0x20
	}
	if m.PmtpPeriodStartBlock != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.PmtpPeriodStartBlock))
		i--
		dAtA[i] = 0x18
	}
	if m.PmtpPeriodEpochLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.PmtpPeriodEpochLength))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.PmtpPeriodGovernanceRate.Size()
		i -= size
		if _, err := m.PmtpPeriodGovernanceRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RewardPeriod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardPeriod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardPeriod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RewardPeriodMod != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.RewardPeriodMod))
		i--
		dAtA[i] = 0x40
	}
	if m.RewardPeriodDistribute {
		i--
		if m.RewardPeriodDistribute {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RewardPeriodDefaultMultiplier != nil {
		{
			size := m.RewardPeriodDefaultMultiplier.Size()
			i -= size
			if _, err := m.RewardPeriodDefaultMultiplier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.RewardPeriodPoolMultipliers) > 0 {
		for iNdEx := len(m.RewardPeriodPoolMultipliers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardPeriodPoolMultipliers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintParams(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.RewardPeriodAllocation != nil {
		{
			size := m.RewardPeriodAllocation.Size()
			i -= size
			if _, err := m.RewardPeriodAllocation.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RewardPeriodEndBlock != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.RewardPeriodEndBlock))
		i--
		dAtA[i] = 0x18
	}
	if m.RewardPeriodStartBlock != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.RewardPeriodStartBlock))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RewardPeriodId) > 0 {
		i -= len(m.RewardPeriodId)
		copy(dAtA[i:], m.RewardPeriodId)
		i = encodeVarintParams(dAtA, i, uint64(len(m.RewardPeriodId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PoolMultiplier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolMultiplier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolMultiplier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Multiplier != nil {
		{
			size := m.Multiplier.Size()
			i -= size
			if _, err := m.Multiplier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.PoolMultiplierAsset) > 0 {
		i -= len(m.PoolMultiplierAsset)
		copy(dAtA[i:], m.PoolMultiplierAsset)
		i = encodeVarintParams(dAtA, i, uint64(len(m.PoolMultiplierAsset)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityProtectionParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityProtectionParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityProtectionParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.EpochLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.EpochLength))
		i--
		dAtA[i] = 0x18
	}
	if len(m.MaxRowanLiquidityThresholdAsset) > 0 {
		i -= len(m.MaxRowanLiquidityThresholdAsset)
		copy(dAtA[i:], m.MaxRowanLiquidityThresholdAsset)
		i = encodeVarintParams(dAtA, i, uint64(len(m.MaxRowanLiquidityThresholdAsset)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.MaxRowanLiquidityThreshold.Size()
		i -= size
		if _, err := m.MaxRowanLiquidityThreshold.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LiquidityProtectionRateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityProtectionRateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityProtectionRateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CurrentRowanLiquidityThreshold.Size()
		i -= size
		if _, err := m.CurrentRowanLiquidityThreshold.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ProviderDistributionPeriod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderDistributionPeriod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderDistributionPeriod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DistributionPeriodMod != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.DistributionPeriodMod))
		i--
		dAtA[i] = 0x20
	}
	if m.DistributionPeriodEndBlock != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.DistributionPeriodEndBlock))
		i--
		dAtA[i] = 0x18
	}
	if m.DistributionPeriodStartBlock != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.DistributionPeriodStartBlock))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.DistributionPeriodBlockRate.Size()
		i -= size
		if _, err := m.DistributionPeriodBlockRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ProviderDistributionParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderDistributionParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderDistributionParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DistributionPeriods) > 0 {
		for iNdEx := len(m.DistributionPeriods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DistributionPeriods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintParams(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int {
	offset -= sovParams(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinCreatePoolThreshold != 0 {
		n += 1 + sovParams(uint64(m.MinCreatePoolThreshold))
	}
	if m.EnableRemovalQueue {
		n += 2
	}
	return n
}

func (m *RewardParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LiquidityRemovalLockPeriod != 0 {
		n += 1 + sovParams(uint64(m.LiquidityRemovalLockPeriod))
	}
	if m.LiquidityRemovalCancelPeriod != 0 {
		n += 1 + sovParams(uint64(m.LiquidityRemovalCancelPeriod))
	}
	if len(m.RewardPeriods) > 0 {
		for _, e := range m.RewardPeriods {
			l = e.Size()
			n += 1 + l + sovParams(uint64(l))
		}
	}
	l = len(m.RewardPeriodStartTime)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	return n
}

func (m *PmtpRateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PmtpPeriodBlockRate.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.PmtpCurrentRunningRate.Size()
	n += 1 + l + sovParams(uint64(l))
	l = m.PmtpInterPolicyRate.Size()
	n += 1 + l + sovParams(uint64(l))
	return n
}

func (m *PmtpParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PmtpPeriodGovernanceRate.Size()
	n += 1 + l + sovParams(uint64(l))
	if m.PmtpPeriodEpochLength != 0 {
		n += 1 + sovParams(uint64(m.PmtpPeriodEpochLength))
	}
	if m.PmtpPeriodStartBlock != 0 {
		n += 1 + sovParams(uint64(m.PmtpPeriodStartBlock))
	}
	if m.PmtpPeriodEndBlock != 0 {
		n += 1 + sovParams(uint64(m.PmtpPeriodEndBlock))
	}
	return n
}

func (m *RewardPeriod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RewardPeriodId)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	if m.RewardPeriodStartBlock != 0 {
		n += 1 + sovParams(uint64(m.RewardPeriodStartBlock))
	}
	if m.RewardPeriodEndBlock != 0 {
		n += 1 + sovParams(uint64(m.RewardPeriodEndBlock))
	}
	if m.RewardPeriodAllocation != nil {
		l = m.RewardPeriodAllocation.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if len(m.RewardPeriodPoolMultipliers) > 0 {
		for _, e := range m.RewardPeriodPoolMultipliers {
			l = e.Size()
			n += 1 + l + sovParams(uint64(l))
		}
	}
	if m.RewardPeriodDefaultMultiplier != nil {
		l = m.RewardPeriodDefaultMultiplier.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.RewardPeriodDistribute {
		n += 2
	}
	if m.RewardPeriodMod != 0 {
		n += 1 + sovParams(uint64(m.RewardPeriodMod))
	}
	return n
}

func (m *PoolMultiplier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PoolMultiplierAsset)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	if m.Multiplier != nil {
		l = m.Multiplier.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	return n
}

func (m *LiquidityProtectionParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MaxRowanLiquidityThreshold.Size()
	n += 1 + l + sovParams(uint64(l))
	l = len(m.MaxRowanLiquidityThresholdAsset)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	if m.EpochLength != 0 {
		n += 1 + sovParams(uint64(m.EpochLength))
	}
	if m.IsActive {
		n += 2
	}
	return n
}

func (m *LiquidityProtectionRateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CurrentRowanLiquidityThreshold.Size()
	n += 1 + l + sovParams(uint64(l))
	return n
}

func (m *ProviderDistributionPeriod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.DistributionPeriodBlockRate.Size()
	n += 1 + l + sovParams(uint64(l))
	if m.DistributionPeriodStartBlock != 0 {
		n += 1 + sovParams(uint64(m.DistributionPeriodStartBlock))
	}
	if m.DistributionPeriodEndBlock != 0 {
		n += 1 + sovParams(uint64(m.DistributionPeriodEndBlock))
	}
	if m.DistributionPeriodMod != 0 {
		n += 1 + sovParams(uint64(m.DistributionPeriodMod))
	}
	return n
}

func (m *ProviderDistributionParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DistributionPeriods) > 0 {
		for _, e := range m.DistributionPeriods {
			l = e.Size()
			n += 1 + l + sovParams(uint64(l))
		}
	}
	return n
}

func sovParams(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozParams(x uint64) (n int) {
	return sovParams(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCreatePoolThreshold", wireType)
			}
			m.MinCreatePoolThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCreatePoolThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableRemovalQueue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableRemovalQueue = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityRemovalLockPeriod", wireType)
			}
			m.LiquidityRemovalLockPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiquidityRemovalLockPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityRemovalCancelPeriod", wireType)
			}
			m.LiquidityRemovalCancelPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiquidityRemovalCancelPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardPeriods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardPeriods = append(m.RewardPeriods, &RewardPeriod{})
			if err := m.RewardPeriods[len(m.RewardPeriods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardPeriodStartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardPeriodStartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PmtpRateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PmtpRateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PmtpRateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PmtpPeriodBlockRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PmtpPeriodBlockRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PmtpCurrentRunningRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PmtpCurrentRunningRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PmtpInterPolicyRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PmtpInterPolicyRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PmtpParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PmtpParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PmtpParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PmtpPeriodGovernanceRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PmtpPeriodGovernanceRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PmtpPeriodEpochLength", wireType)
			}
			m.PmtpPeriodEpochLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PmtpPeriodEpochLength |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PmtpPeriodStartBlock", wireType)
			}
			m.PmtpPeriodStartBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PmtpPeriodStartBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PmtpPeriodEndBlock", wireType)
			}
			m.PmtpPeriodEndBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PmtpPeriodEndBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardPeriod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardPeriod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardPeriod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardPeriodId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardPeriodId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardPeriodStartBlock", wireType)
			}
			m.RewardPeriodStartBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardPeriodStartBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardPeriodEndBlock", wireType)
			}
			m.RewardPeriodEndBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardPeriodEndBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardPeriodAllocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Uint
			m.RewardPeriodAllocation = &v
			if err := m.RewardPeriodAllocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardPeriodPoolMultipliers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardPeriodPoolMultipliers = append(m.RewardPeriodPoolMultipliers, &PoolMultiplier{})
			if err := m.RewardPeriodPoolMultipliers[len(m.RewardPeriodPoolMultipliers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardPeriodDefaultMultiplier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.RewardPeriodDefaultMultiplier = &v
			if err := m.RewardPeriodDefaultMultiplier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardPeriodDistribute", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RewardPeriodDistribute = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardPeriodMod", wireType)
			}
			m.RewardPeriodMod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardPeriodMod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolMultiplier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolMultiplier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolMultiplier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolMultiplierAsset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolMultiplierAsset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiplier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.Multiplier = &v
			if err := m.Multiplier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityProtectionParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityProtectionParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityProtectionParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRowanLiquidityThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxRowanLiquidityThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRowanLiquidityThresholdAsset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxRowanLiquidityThresholdAsset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochLength", wireType)
			}
			m.EpochLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityProtectionRateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityProtectionRateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityProtectionRateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentRowanLiquidityThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrentRowanLiquidityThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderDistributionPeriod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderDistributionPeriod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderDistributionPeriod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributionPeriodBlockRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DistributionPeriodBlockRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributionPeriodStartBlock", wireType)
			}
			m.DistributionPeriodStartBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistributionPeriodStartBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributionPeriodEndBlock", wireType)
			}
			m.DistributionPeriodEndBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistributionPeriodEndBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributionPeriodMod", wireType)
			}
			m.DistributionPeriodMod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistributionPeriodMod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderDistributionParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderDistributionParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderDistributionParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributionPeriods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DistributionPeriods = append(m.DistributionPeriods, &ProviderDistributionPeriod{})
			if err := m.DistributionPeriods[len(m.DistributionPeriods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipParams(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowParams
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthParams
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupParams
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthParams
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
